package answer;

//题目描述：
//攀登者喜欢寻找各种地图，并且尝试攀登到最高的山峰。
//地图表示为一维数组，数组的索引代表水平位置，数组的高度代表相对海拔高度。其中数组元素0代表地面。
//例如[0,1,2,4,3,1,0,0,1,2,3,1,2,1,0], 代表如下图所示的地图，地图中有两个山脉位置分别为 1,2,3,4,5和8,9,10,11,12,13，最高峰高度分别为 4,3。最高峰位置分别为3,10。
//一个山脉可能有多座山峰(高度大于相邻位置的高度，或在地图边界且高度大于相邻的高度)。
//                4
//
//              +---+
//              |   |
//              |   | 3                       3
//              |   |
//              |   +---+                   -----
//              |       |                   |   |
//            2 |       |                 2 |   |     2
//              |       |                   |   |
//          +---+       |               ----+   |   +---+
//          |           |               |       |   |   |
//        1 |           | 1           1 |       | 1 |   | 1
//          |           |               |       |   |   |
//      +---+           +---+       +---+       +---+   +---+
//      |                   |       |                       |
//    0 |                   | 0   0 |                       | 0
//      |                   |       |                       |
//  +---+                   +-------+                       +---+
//
//    0   1   2   3   4   5   6   7   8   9  10  11  12  13  14
//
//输入描述
//输入一个整数数组，数组长度大于1
//
//输出描述
//输出地图中山峰的数量
//
//用例1
//输入
//0, 1, 2, 3, 2, 4
//输出2
//
//用例2
//输入0,1,4,3,1,0,0,1,2,3,1,2,1,0
//输出3

public class Solution2 {

    public static void main(String[] args) {
        // 测试用例1
        int[] heights1 = {0, 1, 2, 3, 2, 4};
        System.out.println(countPeaks(heights1)); // 应输出2

        // 测试用例2
        int[] heights2 = {0, 1, 4, 3, 1, 0, 0, 1, 2, 3, 1, 2, 1, 0};
        System.out.println(countPeaks(heights2)); // 应输出3
    }

    public static int countPeaks(int[] heights) {
        if (heights == null || heights.length < 2) {
            return 0; // 如果数组为空或长度小于2，则没有山峰
        }

        int peakCount = 0;

        // 检查第一个元素是否是山峰
        if (heights[0] > heights[1]) {
            peakCount++;
        }

        // 检查中间的元素是否是山峰
        for (int i = 1; i < heights.length - 1; i++) {
            if (heights[i] > heights[i - 1] && heights[i] > heights[i + 1]) {
                peakCount++;
            }
        }

        // 检查最后一个元素是否是山峰
        if (heights[heights.length - 1] > heights[heights.length - 2]) {
            peakCount++;
        }

        return peakCount;
    }

}

//为了解决这个问题，我们可以编写一个Java方法，该方法将接受一个整数数组作为输入，并返回地图中山峰的数量。以下是解决方案的步骤：
//
//遍历数组，从第二个元素开始到倒数第二个元素结束。
//对于每个元素，检查它是否比它的前一个和后一个元素都要高。如果是，则认为找到了一个山峰。
//特别注意数组的边界情况：如果数组的第一个或最后一个元素比相邻的元素高，则也应该被视为山峰。
//计算所有满足条件的山峰数量并返回。